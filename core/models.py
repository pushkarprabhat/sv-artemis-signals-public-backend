# core/models.py — STRATEGY BASE CLASS & DOMAIN MODELS
# Abstract base classes for all strategies, reusable and extensible
# Built for Artemis Signals trading platform

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from datetime import datetime
import pandas as pd
import numpy as np
from enum import Enum
from utils.logger import logger


class OrderType(Enum):
    """Order types supported by the platform"""
    BUY = "BUY"
    SELL = "SELL"
    SHORT = "SHORT"
    EXIT = "EXIT"
    CANCEL = "CANCEL"


class PositionType(Enum):
    """Position types"""
    LONG = "LONG"
    SHORT = "SHORT"
    PAIR_LONG = "PAIR_LONG"  # Long symbol A, short symbol B
    PAIR_SHORT = "PAIR_SHORT"  # Short symbol A, long symbol B


@dataclass
class Signal:
    """Trading signal generated by a strategy"""
    symbol: str
    timestamp: datetime
    strategy_name: str
    signal_type: PositionType
    entry_price: float
    confidence: float  # 0-100
    stop_loss: float
    take_profit: float
    position_size: float
    kelly_fraction: float
    z_score: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        """Convert signal to dictionary"""
        return {
            'symbol': self.symbol,
            'timestamp': self.timestamp.isoformat(),
            'strategy': self.strategy_name,
            'type': self.signal_type.value,
            'entry_price': self.entry_price,
            'confidence': self.confidence,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'position_size': self.position_size,
            'kelly_fraction': self.kelly_fraction,
            'z_score': self.z_score,
            'metadata': self.metadata
        }


@dataclass
class Trade:
    """Represents a trade (entry + exit)"""
    trade_id: str
    symbol: str
    entry_time: datetime
    entry_price: float
    exit_time: Optional[datetime] = None
    exit_price: Optional[float] = None
    quantity: float = 0
    position_type: PositionType = PositionType.LONG
    pnl: float = 0.0
    pnl_percent: float = 0.0
    exit_reason: Optional[str] = None
    strategy: str = ""
    
    def to_dict(self) -> Dict:
        return {
            'trade_id': self.trade_id,
            'symbol': self.symbol,
            'entry_time': self.entry_time.isoformat(),
            'entry_price': self.entry_price,
            'exit_time': self.exit_time.isoformat() if self.exit_time else None,
            'exit_price': self.exit_price,
            'quantity': self.quantity,
            'position_type': self.position_type.value,
            'pnl': self.pnl,
            'pnl_percent': self.pnl_percent,
            'exit_reason': self.exit_reason,
            'strategy': self.strategy
        }


@dataclass
class BacktestMetrics:
    """Backtesting performance metrics"""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    win_rate: float = 0.0
    total_pnl: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    profit_factor: float = 0.0
    avg_win: float = 0.0
    avg_loss: float = 0.0
    consecutive_wins: int = 0
    consecutive_losses: int = 0
    
    def to_dict(self) -> Dict:
        return {
            'total_trades': self.total_trades,
            'winning_trades': self.winning_trades,
            'losing_trades': self.losing_trades,
            'win_rate': round(self.win_rate, 2),
            'total_pnl': round(self.total_pnl, 2),
            'max_drawdown': round(self.max_drawdown, 2),
            'sharpe_ratio': round(self.sharpe_ratio, 2),
            'profit_factor': round(self.profit_factor, 2),
            'avg_win': round(self.avg_win, 2),
            'avg_loss': round(self.avg_loss, 2)
        }


class StrategyBase(ABC):
    """
    Abstract base class for all trading strategies.
    
    Provides:
    - Unified interface for scan(), backtest(), execute()
    - Error handling and logging
    - Configuration management
    - Signal generation
    - Trade tracking
    
    Usage:
        class MyStrategy(StrategyBase):
            def scan(self, data, **kwargs):
                # Implement scan logic
                return signals
            
            def backtest(self, historical_data):
                # Implement backtest logic
                return metrics
            
            def execute(self, signal):
                # Implement execution logic
                return trade_result
    """
    
    def __init__(
        self,
        name: str,
        capital: float = 100000,
        max_position_size: float = 0.02,  # 2% max
        kelly_fraction: float = 0.25,  # Conservative Kelly
        enable_logging: bool = True
    ):
        """
        Initialize strategy base.
        
        Args:
            name: Strategy name (e.g., "Pair Trading", "Momentum")
            capital: Capital available for trading
            max_position_size: Max position as % of capital
            kelly_fraction: Kelly criterion multiplier (0-1)
            enable_logging: Enable detailed logging
        """
        self.name = name
        self.capital = capital
        self.max_position_size = max_position_size
        self.kelly_fraction = kelly_fraction
        self.enable_logging = enable_logging
        
        # Internal tracking
        self.signals: List[Signal] = []
        self.trades: List[Trade] = []
        self.equity_curve: List[float] = [capital]
        self.last_error: Optional[str] = None
        
        if enable_logging:
            logger.info(f"✓ Strategy initialized: {name}")
    
    @abstractmethod
    def scan(self, data: Dict[str, pd.DataFrame], **kwargs) -> List[Signal]:
        """
        Scan for trading signals.
        
        Args:
            data: Dictionary of symbol -> price dataframe
            **kwargs: Additional scan parameters
        
        Returns:
            List of Signal objects
        
        Raises:
            Should catch exceptions and log, returning empty list on error
        """
        pass
    
    @abstractmethod
    def backtest(
        self,
        historical_data: Dict[str, pd.DataFrame],
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None
    ) -> BacktestMetrics:
        """
        Backtest the strategy on historical data.
        
        Args:
            historical_data: Dictionary of symbol -> price dataframe with full history
            start_date: Start of backtest period
            end_date: End of backtest period
        
        Returns:
            BacktestMetrics with performance statistics
        """
        pass
    
    @abstractmethod
    def execute(self, signal: Signal, live: bool = False) -> Dict[str, Any]:
        """
        Execute a signal (paper or live).
        
        Args:
            signal: Signal to execute
            live: If True, place real order; if False, simulate
        
        Returns:
            Dictionary with execution result:
            {
                'status': 'SUCCESS' or 'FAILED',
                'message': str,
                'trade_id': str,
                'order_id': str (if live)
            }
        """
        pass
    
    # ========================================================================
    # COMMON UTILITY METHODS
    # ========================================================================
    
    def validate_input_data(self, data: Dict[str, pd.DataFrame], required_columns: List[str] = None) -> bool:
        """
        Validate input data quality before scanning.
        
        Args:
            data: Dictionary of symbol -> dataframe
            required_columns: Columns to check for (default: ['close', 'volume'])
        
        Returns:
            True if valid, False otherwise (with error logged)
        """
        if required_columns is None:
            required_columns = ['close', 'volume']
        
        try:
            if not data or not isinstance(data, dict):
                self._log(f"Input data is empty or not a dictionary", level='error')
                return False
            
            for symbol, df in data.items():
                if df.empty:
                    self._log(f"{symbol}: Empty dataframe", level='warning')
                    return False
                
                missing_cols = [col for col in required_columns if col not in df.columns]
                if missing_cols:
                    self._log(f"{symbol}: Missing columns {missing_cols}", level='error')
                    return False
                
                if df['volume'].sum() == 0:
                    self._log(f"{symbol}: Zero volume detected", level='error')
                    return False
            
            return True
        except Exception as e:
            self.last_error = str(e)
            self._log(f"Data validation failed: {e}", level='error')
            return False
    
    def calculate_position_size(self, entry_price: float, stop_loss: float, risk_amount: float) -> float:
        """
        Calculate position size using Kelly criterion.
        
        Args:
            entry_price: Entry price
            stop_loss: Stop loss price
            risk_amount: Risk amount in rupees
        
        Returns:
            Position size (quantity)
        """
        try:
            stop_distance = abs(entry_price - stop_loss)
            if stop_distance == 0:
                self._log("Stop loss distance is zero", level='error')
                return 0
            
            position_size = risk_amount / stop_distance
            
            # Apply Kelly fraction
            position_size *= self.kelly_fraction
            
            # Apply max position size limit
            max_size = (self.capital * self.max_position_size) / entry_price
            position_size = min(position_size, max_size)
            
            return position_size
        except Exception as e:
            self._log(f"Position size calculation failed: {e}", level='error')
            return 0
    
    def _log(self, message: str, level: str = 'info'):
        """Internal logging helper"""
        if not self.enable_logging:
            return
        
        prefix = f"[{self.name}]"
        if level == 'error':
            logger.error(f"{prefix} {message}")
        elif level == 'warning':
            logger.warning(f"{prefix} {message}")
        else:
            logger.info(f"{prefix} {message}")
    
    def get_stats(self) -> Dict[str, Any]:
        """Get current strategy statistics"""
        if not self.trades:
            return {
                'signals_generated': len(self.signals),
                'trades_executed': 0,
                'current_equity': self.capital,
                'total_pnl': 0,
                'win_rate': 0
            }
        
        closed_trades = [t for t in self.trades if t.exit_price is not None]
        wins = len([t for t in closed_trades if t.pnl > 0])
        total_pnl = sum([t.pnl for t in closed_trades])
        
        return {
            'signals_generated': len(self.signals),
            'trades_executed': len(self.trades),
            'closed_trades': len(closed_trades),
            'current_equity': self.capital + total_pnl,
            'total_pnl': total_pnl,
            'win_rate': wins / len(closed_trades) if closed_trades else 0,
            'winning_trades': wins,
            'losing_trades': len(closed_trades) - wins
        }


# ============================================================================
# CONCRETE STRATEGY BASE CLASSES (Ready to extend)
# ============================================================================

class PairTradingStrategyBase(StrategyBase):
    """Base for pair trading strategies"""
    
    def __init__(self, name: str = "Pair Trading", **kwargs):
        super().__init__(name, **kwargs)
        self.pairs: List[Tuple[str, str]] = []
    
    def add_pair(self, symbol_a: str, symbol_b: str):
        """Add a pair to monitor"""
        self.pairs.append((symbol_a, symbol_b))


class MomentumStrategyBase(StrategyBase):
    """Base for momentum strategies"""
    
    def __init__(self, name: str = "Momentum Trading", **kwargs):
        super().__init__(name, **kwargs)
        self.indicators_config = {}


class VolatilityStrategyBase(StrategyBase):
    """Base for volatility-based strategies (strangles, straddles, etc)"""
    
    def __init__(self, name: str = "Volatility Strategy", **kwargs):
        super().__init__(name, **kwargs)
        self.iv_threshold = 0.5  # 50th percentile default


# ============================================================================
# CONFIGURATION MODEL
# ============================================================================

@dataclass
class StrategyConfig:
    """Configuration for a strategy run"""
    strategy_name: str
    enabled: bool = True
    capital_allocation: float = 100000  # per strategy
    max_positions: int = 5  # concurrent positions
    max_drawdown: float = 0.10  # 10% max drawdown
    risk_per_trade: float = 0.02  # 2% risk
    live_mode: bool = False  # Paper or Live
    notify_telegram: bool = True
    notify_email: bool = False
    backtest_enabled: bool = True
    
    def to_dict(self) -> Dict:
        return {
            'strategy': self.strategy_name,
            'enabled': self.enabled,
            'capital': self.capital_allocation,
            'max_positions': self.max_positions,
            'risk_per_trade': self.risk_per_trade,
            'live': self.live_mode,
            'backtest': self.backtest_enabled
        }
